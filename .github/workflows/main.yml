name: Update Comprehensive SRS

on:
  workflow_dispatch:
  schedule:
    - cron: '0 20 * * *' # åŒ—äº¬æ—¶é—´å‡Œæ™¨ 4 ç‚¹è¿è¡Œ
  push:
    paths:
      - '.github/workflows/**'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install Dependencies
        run: pip install dnspython requests

      - name: Install sing-box
        run: |
          LATEST_TAG=$(curl -s "https://api.github.com/repos/SagerNet/sing-box/releases/latest" | grep -Po '"tag_name": "\K.*?(?=")')
          VERSION_NUM=${LATEST_TAG#v}
          curl -Lo sing-box.tar.gz "https://github.com/SagerNet/sing-box/releases/download/${LATEST_TAG}/sing-box-${VERSION_NUM}-linux-amd64.tar.gz"
          tar -xvf sing-box.tar.gz
          mv sing-box-*/sing-box .
          chmod +x sing-box

      # ----------------------------------------------------------------
      # é˜¶æ®µ 1: ä¸‰æºåˆå¹¶ (S1 å¿…ä¿, S2/S3 äº¤å‰å°è¯)
      # ----------------------------------------------------------------
      - name: Stage 1 - Consensus Merge
        run: |
          curl -sL "https://raw.githubusercontent.com/77160860/rule/refs/heads/main/filter.json" -o s1.json
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/fakeip-filter.srs" -o s2.srs
          ./sing-box rule-set decompile s2.srs -o s2.json
          curl -sL "https://raw.githubusercontent.com/HenryChiao/mihomo_yamls/refs/heads/main/custom/domain/fake-ip-filter.list" -o s3.list

          python3 -c "
          import json, re, os
          
          registry = {} # key: (type, val) -> sources set

          def add_to_reg(val, r_type, src):
              if r_type != 'domain_regex': val = val.strip().lower()
              if not val: return
              key = (r_type, val)
              if key not in registry: registry[key] = set()
              registry[key].add(src)

          # åŠ è½½ S1 (JSON)
          with open('s1.json', 'r') as f:
              d = json.load(f)
              for r in d.get('rules', []):
                  for k in ['domain', 'domain_suffix', 'domain_keyword', 'domain_regex']:
                      for v in r.get(k, []): add_to_reg(v, k, 'S1')

          # åŠ è½½ S2 (JSON)
          with open('s2.json', 'r') as f:
              d = json.load(f)
              for r in d.get('rules', []):
                  for k in ['domain', 'domain_suffix', 'domain_keyword', 'domain_regex']:
                      for v in r.get(k, []): add_to_reg(v, k, 'S2')

          # åŠ è½½ S3 (List)
          if os.path.exists('s3.list'):
              for line in open('s3.list'):
                  l = line.strip()
                  if not l or l.startswith('#'): continue
                  if l.startswith('.'): add_to_reg(l.lstrip('.'), 'domain_suffix', 'S3')
                  else: add_to_reg(l, 'domain', 'S3')

          # åˆ¤å®šé€»è¾‘ï¼šS1ä¸€å®šä¿ç•™ï¼Œæˆ–è€… (S2ä¸”S3) äº¤å‰å­˜åœ¨
          final_rules = {'domain': [], 'domain_suffix': [], 'domain_keyword': [], 'domain_regex': []}
          for (r_type, val), sources in registry.items():
              if 'S1' in sources or ('S2' in sources and 'S3' in sources):
                  final_rules[r_type].append(val)

          # æ ¼å¼å¯¹é½ S1 å¹¶ä¿å­˜
          output = {'version': 3, 'rules': [{k: sorted(v) for k, v in final_rules.items() if v}]}
          with open('fakeip-filter.json', 'w') as f:
              json.dump(output, f, indent=2)
          "
          ./sing-box rule-set compile fakeip-filter.json -o fakeip-filter.srs

      # ----------------------------------------------------------------
      # é˜¶æ®µ 2: æ·±åº¦æ¸…æ´— (Remote-DNS é€»è¾‘)
      # ----------------------------------------------------------------
      - name: Stage 2 - Deep Classification
        run: |
          # ä¸‹è½½ç™½åå•å’Œè·¯ç”±è¡¨
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/cn.srs" -o cn_full.srs
          curl -sL "https://github.com/DustinWin/ruleset_geodata/releases/download/sing-box-ruleset/private.srs" -o private.srs
          curl -sL "https://raw.githubusercontent.com/YiXuanZX/sing-box-geosite/main/rule/cn-additional-list-clash-classical.srs" -o cn-add.srs
          curl -sL "https://raw.githubusercontent.com/misakaio/chnroutes2/master/chnroutes.txt" -o chnroutes.txt
          
          ./sing-box rule-set decompile cn_full.srs -o cn_full.json
          ./sing-box rule-set decompile private.srs -o private.json
          ./sing-box rule-set decompile cn-add.srs -o cn-add.json

          python3 -c "
          import json, dns.resolver, ipaddress, concurrent.futures, os

          # 1. åŠ è½½æ‰€æœ‰æœ¬åœ°é™æ€ç‰¹å¾
          local_exact = set()
          local_suffix = set()
          
          def load_white(path):
              if not os.path.exists(path): return
              with open(path, 'r') as f:
                  d = json.load(f)
                  for r in d.get('rules', []):
                      for x in r.get('domain', []): local_exact.add(x.lower())
                      for x in r.get('domain_suffix', []): local_suffix.add(x.lower())

          for p in ['cn_full.json', 'private.json', 'cn-add.json']:
              load_white(p)

          # 2. åŠ è½½ä¸­å›½ IP æ®µ
          cn_nets = [ipaddress.ip_network(l.strip()) for l in open('chnroutes.txt') if l.strip() and not l.startswith('#')]
          
          # 3. DNS è§£æå™¨é…ç½®
          resolver = dns.resolver.Resolver()
          resolver.nameservers = ['8.8.8.8', '1.1.1.1']
          resolver.timeout = 1.5

          def check_is_local(domain):
              d = domain.lower().strip('.')
              # æ¡ä»¶1: .cn ç»“å°¾
              if d.endswith('.cn'): return True
              # æ¡ä»¶2: ç™½åå•ç²¾ç¡®åŒ¹é…
              if d in local_exact: return True
              # æ¡ä»¶3: ç™½åå•åç¼€åŒ¹é…
              parts = d.split('.')
              for i in range(len(parts)):
                  if '.'.join(parts[i:]) in local_suffix: return True
              # æ¡ä»¶4: DNS è§£æå½’å±åœ°éªŒè¯
              try:
                  ans = resolver.resolve(d, 'A')
                  ip_obj = ipaddress.ip_address(ans[0].to_text())
                  if any(ip_obj in net for net in cn_nets): return True
              except: pass
              return False

          # å¤„ç† fakeip-filter.json ä¸­çš„æ‰€æœ‰åŸŸå
          with open('fakeip-filter.json', 'r') as f:
              source = json.load(f)

          remote_rules = {'domain': [], 'domain_suffix': [], 'domain_keyword': [], 'domain_regex': []}
          
          # æå–å¾…æ£€æµ‹åˆ—è¡¨
          rules_obj = source['rules'][0]
          # Regex å’Œ Keyword é»˜è®¤ä¿ç•™ï¼ˆä¸è¿›è¡Œè§£æåˆ¤æ–­ï¼‰ï¼Œå› ä¸ºå®ƒä»¬æ˜¯æ¨¡ç³ŠåŒ¹é…
          remote_rules['domain_keyword'] = rules_obj.get('domain_keyword', [])
          remote_rules['domain_regex'] = rules_obj.get('domain_regex', [])

          to_check = []
          for d in rules_obj.get('domain', []): to_check.append((d, 'domain'))
          for d in rules_obj.get('domain_suffix', []): to_check.append((d, 'domain_suffix'))

          print(f'Starting cleaning. Total domains to check: {len(to_check)}')

          with concurrent.futures.ThreadPoolExecutor(max_workers=30) as exe:
              futures = {exe.submit(check_is_local, item[0]): item for item in to_check}
              for f in concurrent.futures.as_completed(futures):
                  domain, r_type = futures[f]
                  if not f.result(): # å¦‚æœä¸æ˜¯æœ¬åœ°ï¼Œåˆ™ä¿ç•™åˆ°è¿œç¨‹
                      remote_rules[r_type].append(domain)

          # æœ€ç»ˆå»é‡ï¼šå¦‚æœ suffix æ¶µç›–äº† domainï¼Œç§»é™¤ domain
          s_set = set(remote_rules['domain_suffix'])
          remote_rules['domain'] = [d for d in remote_rules['domain'] if not any(d.endswith('.' + s) or d == s for s in s_set)]

          with open('fakeip-filter-Remote-DNS.json', 'w') as f:
              json.dump({'version': 3, 'rules': [{k: sorted(v) for k, v in remote_rules.items() if v}]}, f, indent=2)
          "
          ./sing-box rule-set compile fakeip-filter-Remote-DNS.json -o fakeip-filter-Remote-DNS.srs

      # ----------------------------------------------------------------
      # é˜¶æ®µ 3: WebRTC & æäº¤
      # ----------------------------------------------------------------
      - name: Stage 3 - Finalize
        run: |
          curl -sL "https://raw.githubusercontent.com/Kris-Channnn/sing-box-proxy/refs/heads/main/webRTC.json" -o raw_webrtc.json
          python3 -c "import json; d=json.load(open('raw_webrtc.json')); open('webRTC.json','w').write(json.dumps({'version': 3, 'rules': d.get('rules', [])}, indent=2))"
          ./sing-box rule-set compile webRTC.json -o webRTC.srs

          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"
          rm -f s1.json s2.json s2.srs s3.list raw_webrtc.json sing-box sing-box.tar.gz chnroutes.txt \
                cn_full.srs cn_full.json private.srs private.json cn-add.srs cn-add.json
          git add *.json *.srs
          if git diff --staged --quiet; then
            echo "No changes"
          else
            git commit -m "ğŸš€ Sync & Deep Clean: Weighted Consensus + DNS Verify ($(date +'%Y-%m-%d'))"
            git push origin main --force
          fi
